{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport { elementScroll } from \"./scroll.js\"; // https://drafts.csswg.org/css-writing-modes-4/#block-flow\n\nconst normalizeWritingMode = writingMode => {\n  switch (writingMode) {\n    case \"horizontal-tb\":\n    case \"lr\":\n    case \"lr-tb\":\n    case \"rl\":\n    case \"rl-tb\":\n      return 0\n      /* HorizontalTb */\n      ;\n\n    case \"vertical-rl\":\n    case \"tb\":\n    case \"tb-rl\":\n      return 1\n      /* VerticalRl */\n      ;\n\n    case \"vertical-lr\":\n    case \"tb-lr\":\n      return 2\n      /* VerticalLr */\n      ;\n\n    case \"sideways-rl\":\n      return 3\n      /* SidewaysRl */\n      ;\n\n    case \"sideways-lr\":\n      return 4\n      /* SidewaysLr */\n      ;\n  }\n\n  return 0\n  /* HorizontalTb */\n  ;\n};\n\nconst calcPhysicalAxis = (writingMode, isLTR, hPos, vPos) => {\n  /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n  let layout = 0b00;\n  /**\n   * WritingMode.VerticalLr: ↓→\n   * | 1 | 4 |   |\n   * | 2 | 5 |   |\n   * | 3 |   |   |\n   *\n   * RTL: ↑→\n   * | 3 |   |   |\n   * | 2 | 5 |   |\n   * | 1 | 4 |   |\n   */\n\n  if (!isLTR) {\n    layout ^= 2\n    /* ReverseVertical */\n    ;\n  }\n\n  switch (writingMode) {\n    /**\n     * ↓→\n     * | 1 | 2 | 3 |\n     * | 4 | 5 |   |\n     * |   |   |   |\n     *\n     * RTL: ↓←\n     * | 3 | 2 | 1 |\n     * |   | 5 | 4 |\n     * |   |   |   |\n     */\n    case 0\n    /* HorizontalTb */\n    :\n      // swap horizontal and vertical\n      layout = layout >> 1 | (layout & 1) << 1;\n      [hPos, vPos] = [vPos, hPos];\n      break;\n\n    /**\n     * ↓←\n     * |   | 4 | 1 |\n     * |   | 5 | 2 |\n     * |   |   | 3 |\n     *\n     * RTL: ↑←\n     * |   |   | 3 |\n     * |   | 5 | 2 |\n     * |   | 4 | 1 |\n     */\n\n    case 1\n    /* VerticalRl */\n    :\n    case 3\n    /* SidewaysRl */\n    :\n      //  reverse horizontal\n      layout ^= 1\n      /* ReverseHorizontal */\n      ;\n      break;\n\n    /**\n     * ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     *\n     * RTL: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     */\n\n    case 4\n    /* SidewaysLr */\n    :\n      // reverse vertical\n      layout ^= 2\n      /* ReverseVertical */\n      ;\n      break;\n  }\n\n  return [layout, hPos, vPos];\n};\n\nconst isXReversed = computedStyle => {\n  const layout = calcPhysicalAxis(normalizeWritingMode(computedStyle.writingMode), computedStyle.direction !== \"rtl\", undefined, undefined)[0];\n  return (layout & 1) === 1;\n}; // https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\n\n\nconst toPhysicalAlignment = (options, writingMode, isLTR) => {\n  const [layout, hPos, vPos] = calcPhysicalAxis(writingMode, isLTR, options.block || \"start\", options.inline || \"nearest\");\n  return [hPos, vPos].map((value, index) => {\n    switch (value) {\n      case \"center\":\n        return 1\n        /* CenterAlways */\n        ;\n\n      case \"nearest\":\n        return 0\n        /* ToEdgeIfNeeded */\n        ;\n\n      default:\n        {\n          const reverse = layout >> index & 1;\n          return value === \"start\" === !reverse ? 2\n          /* LeftOrTop */\n          : 3\n          /* RightOrBottom */\n          ;\n        }\n    }\n  });\n}; // code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\n\n\nconst mapNearest = (align, scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) => {\n  if (align !== 0\n  /* ToEdgeIfNeeded */\n  ) {\n    return align;\n  }\n  /**\n   * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓\n   *          │  │\n   *        ┃ │  │ ┃        do nothing\n   *          │  │\n   *        ┗━│━━│━┛\n   *          └──┘\n   *\n   *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n   *\n   *    ┏ ━ ━ ━ ━ ┓\n   *   ┌───────────┐\n   *   │┃         ┃│        do nothing\n   *   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛\n   */\n\n\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return null;\n  }\n  /**\n   * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n   *\n   *          ┌──┐\n   *        ┏━│━━│━┓         ┏━┌━━┐━┓\n   *          └──┘             │  │\n   *  from  ┃      ┃     to  ┃ └──┘ ┃\n   *\n   *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n   *\n   * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n   *                           │  │\n   *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n   *          │  │             │  │\n   *        ┗━│━━│━┛         ┗━│━━│━┛\n   *          │  │             └──┘\n   *          │  │\n   *          └──┘\n   *\n   * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───┐                 ┌───┐\n   *  │ ┃ │       ┃         ┃   │     ┃\n   *  └───┘                 └───┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n   *\n   *       from                 to\n   *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *        ┌───────────┐   ┌───────────┐\n   *    ┃   │     ┃     │   ┃         ┃ │\n   *        └───────────┘   └───────────┘\n   *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   */\n\n\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return 2\n    /* LeftOrTop */\n    ;\n  }\n  /**\n   * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n   *\n   *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n   *\n   *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n   *          ┌──┐             │  │\n   *        ┗━│━━│━┛         ┗━└━━┘━┛\n   *          └──┘\n   *\n   * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n   *\n   *          ┌──┐\n   *          │  │\n   *          │  │             ┌──┐\n   *        ┏━│━━│━┓         ┏━│━━│━┓\n   *          │  │             │  │\n   *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n   *                           │  │\n   *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n   *\n   * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *  ┌───────────┐           ┌───────────┐\n   *  │     ┃     │   ┃       │ ┃         ┃\n   *  └───────────┘           └───────────┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n   *\n   *           from                 to\n   *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n   *                ┌───┐             ┌───┐\n   *        ┃       │ ┃ │       ┃     │   ┃\n   *                └───┘             └───┘\n   *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n   *\n   */\n\n\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return 3\n    /* RightOrBottom */\n    ;\n  }\n\n  return null;\n};\n\nconst canOverflow = overflow => {\n  return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = element => {\n  try {\n    return element.ownerDocument.defaultView?.frameElement || null;\n  } catch {\n    return null;\n  }\n};\n\nconst isScrollable = (element, computedStyle) => {\n  if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n    return canOverflow(computedStyle.overflowY) || canOverflow(computedStyle.overflowX) || element === scrollingElement(element);\n  }\n\n  return false;\n};\n\nconst parentElement = element => {\n  const pNode = element.parentNode;\n  const pElement = element.parentElement;\n\n  if (pElement === null && pNode !== null) {\n    if (pNode.nodeType ===\n    /** Node.DOCUMENT_FRAGMENT_NODE */\n    11) {\n      return pNode.host;\n    }\n\n    if (pNode.nodeType ===\n    /** Node.DOCUMENT_NODE */\n    9) {\n      return getFrameElement(element);\n    }\n  }\n\n  return pElement;\n};\n\nconst clamp = (value, min, max) => {\n  if (value < min) {\n    return min;\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  return value;\n};\n\nconst getSupportedScrollMarginProperty = ownerDocument => {\n  // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n  return [\"scroll-margin\", \"scroll-snap-margin\"].filter(property => property in ownerDocument.documentElement.style)[0];\n};\n\nconst getElementScrollSnapArea = (element, elementRect, computedStyle) => {\n  const {\n    top,\n    right,\n    bottom,\n    left\n  } = elementRect;\n  const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n\n  if (!scrollProperty) {\n    return [top, right, bottom, left];\n  }\n\n  const scrollMarginValue = edge => {\n    const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n    return parseInt(value, 10) || 0;\n  };\n\n  return [top - scrollMarginValue(\"top\"), right + scrollMarginValue(\"right\"), bottom + scrollMarginValue(\"bottom\"), left - scrollMarginValue(\"left\")];\n};\n\nconst calcAlignEdge = (align, start, end) => {\n  switch (align) {\n    case 1\n    /* CenterAlways */\n    :\n      return (start + end) / 2;\n\n    case 3\n    /* RightOrBottom */\n    :\n      return end;\n\n    case 2\n    /* LeftOrTop */\n    :\n    case 0\n    /* ToEdgeIfNeeded */\n    :\n      return start;\n  }\n};\n\nconst getFrameViewport = (frame, frameRect) => {\n  const visualViewport = frame.ownerDocument.defaultView?.visualViewport;\n  const [x, y, width, height] = frame === scrollingElement(frame) ? [0, 0, visualViewport?.width ?? frame.clientWidth, visualViewport?.height ?? frame.clientHeight] : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n  const left = x + frame.clientLeft;\n  const top = y + frame.clientTop;\n  const right = left + width;\n  const bottom = top + height;\n  return [top, right, bottom, left];\n};\n\nconst computeScrollIntoView = (element, options) => {\n  // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n  const actions = [];\n  let ownerDocument = element.ownerDocument;\n  let ownerWindow = ownerDocument.defaultView;\n\n  if (!ownerWindow) {\n    return actions;\n  }\n\n  const computedStyle = window.getComputedStyle(element);\n  const isLTR = computedStyle.direction !== \"rtl\";\n  const writingMode = normalizeWritingMode(computedStyle.writingMode || computedStyle.getPropertyValue(\"-webkit-writing-mode\") || computedStyle.getPropertyValue(\"-ms-writing-mode\"));\n  const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n  let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n  for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n    if (ownerDocument !== frame.ownerDocument) {\n      ownerDocument = frame.ownerDocument;\n      ownerWindow = ownerDocument.defaultView;\n\n      if (!ownerWindow) {\n        break;\n      }\n\n      const {\n        left: dX,\n        top: dY\n      } = frame.getBoundingClientRect();\n      top += dY;\n      right += dX;\n      bottom += dY;\n      left += dX;\n    }\n\n    const frameStyle = ownerWindow.getComputedStyle(frame);\n\n    if (frameStyle.position === \"fixed\") {\n      break;\n    }\n\n    if (!isScrollable(frame, frameStyle)) {\n      continue;\n    }\n\n    const frameRect = frame.getBoundingClientRect();\n    const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n    const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n    const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n    const diffX = eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n    const diffY = eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n    const moveX = isXReversed(frameStyle) ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft) : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n    const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n    actions.push([frame, {\n      left: frame.scrollLeft + moveX,\n      top: frame.scrollTop + moveY,\n      behavior: options.behavior\n    }]);\n    top = Math.max(top - moveY, frameTop);\n    right = Math.min(right - moveX, frameRight);\n    bottom = Math.min(bottom - moveY, frameBottom);\n    left = Math.max(left - moveX, frameLeft);\n  }\n\n  return actions;\n};\n\nexport const scrollIntoView = (element, scrollIntoViewOptions, config) => {\n  const options = scrollIntoViewOptions || {};\n\n  if (!checkBehavior(options.behavior)) {\n    throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n  }\n\n  const actions = computeScrollIntoView(element, options);\n  actions.forEach(_ref => {\n    let [frame, scrollToOptions] = _ref;\n    elementScroll(frame, scrollToOptions, config);\n  });\n};\nexport const elementScrollIntoView = scrollIntoView;","map":{"version":3,"sources":["/home/kelvin/Desktop/KelvinPichinini.github.io/kelvin-portifolio/node_modules/seamless-scroll-polyfill/src/scrollIntoView.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,aAAT,EAAwB,6BAAxB,EAAuD,gBAAvD,QAA+E,aAA/E;AAEA,SAAS,aAAT,QAA8B,aAA9B,C,CAiBA;;AACA,MAAM,oBAAoB,GAAI,WAAD,IAAqC;AAC9D,UAAQ,WAAR;AACI,SAAK,eAAL;AACA,SAAK,IAAL;AACA,SAAK,OAAL;AACA,SAAK,IAAL;AACA,SAAK,OAAL;AACI,aAAA;AAAA;AAAA;;AAEJ,SAAK,aAAL;AACA,SAAK,IAAL;AACA,SAAK,OAAL;AACI,aAAA;AAAA;AAAA;;AAEJ,SAAK,aAAL;AACA,SAAK,OAAL;AACI,aAAA;AAAA;AAAA;;AAEJ,SAAK,aAAL;AACI,aAAA;AAAA;AAAA;;AAEJ,SAAK,aAAL;AACI,aAAA;AAAA;AAAA;AArBR;;AAwBA,SAAA;AAAA;AAAA;AACH,CA1BD;;AA8BA,MAAM,gBAAgB,GAAG,CAAI,WAAJ,EAA8B,KAA9B,EAA8C,IAA9C,EAAuD,IAAvD,KAAkF;AACvG;AACA,MAAI,MAAM,GAAG,IAAb;AAOA;;;;;;;;;;AAUG;;AACH,MAAI,CAAC,KAAL,EAAY;AACR,IAAA,MAAM,IAAA;AAAA;AAAN;AACH;;AAED,UAAQ,WAAR;AACI;;;;;;;;;;AAUG;AACH,SAAA;AAAA;AAAA;AACI;AACA,MAAA,MAAM,GAAI,MAAM,IAAI,CAAX,GAAiB,CAAC,MAAM,GAAG,CAAV,KAAgB,CAA1C;AACA,OAAC,IAAD,EAAO,IAAP,IAAe,CAAC,IAAD,EAAO,IAAP,CAAf;AACA;;AAEJ;;;;;;;;;;AAUG;;AACH,SAAA;AAAA;AAAA;AACA,SAAA;AAAA;AAAA;AACI;AACA,MAAA,MAAM,IAAA;AAAA;AAAN;AACA;;AAEJ;;;;;;;;;;AAUG;;AACH,SAAA;AAAA;AAAA;AACI;AACA,MAAA,MAAM,IAAA;AAAA;AAAN;AACA;AAjDR;;AAoDA,SAAO,CAAC,MAAD,EAAS,IAAT,EAAe,IAAf,CAAP;AACH,CA7ED;;AA+EA,MAAM,WAAW,GAAI,aAAD,IAA0D;AAC1E,QAAM,MAAM,GAAG,gBAAgB,CAC3B,oBAAoB,CAAC,aAAa,CAAC,WAAf,CADO,EAE3B,aAAa,CAAC,SAAd,KAA4B,KAFD,EAG3B,SAH2B,EAI3B,SAJ2B,CAAhB,CAKb,CALa,CAAf;AAMA,SAAO,CAAC,MAAM,GAAG,CAAV,MAAiB,CAAxB;AACH,CARD,C,CAUA;;;AACA,MAAM,mBAAmB,GAAG,CACxB,OADwB,EAExB,WAFwB,EAGxB,KAHwB,KAIC;AACzB,QAAM,CAAC,MAAD,EAAS,IAAT,EAAe,IAAf,IAAuB,gBAAgB,CACzC,WADyC,EAEzC,KAFyC,EAGzC,OAAO,CAAC,KAAR,IAAiB,OAHwB,EAIzC,OAAO,CAAC,MAAR,IAAkB,SAJuB,CAA7C;AAOA,SAAO,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,CAAiB,CAAC,KAAD,EAAQ,KAAR,KAAiB;AACrC,YAAQ,KAAR;AACI,WAAK,QAAL;AACI,eAAA;AAAA;AAAA;;AACJ,WAAK,SAAL;AACI,eAAA;AAAA;AAAA;;AAEJ;AAAS;AACL,gBAAM,OAAO,GAAI,MAAM,IAAI,KAAX,GAAoB,CAApC;AACA,iBAAQ,KAAK,KAAK,OAAX,KAAwB,CAAC,OAAzB,GAAkC;AAAA;AAAlC,YAA8D;AAAA;AAArE;AACH;AATL;AAWH,GAZM,CAAP;AAaH,CAzBD,C,CA2BA;AACA;;AACA;;;;;;;;AAQG;;;AACH,MAAM,UAAU,GAAG,CACf,KADe,EAEf,kBAFe,EAGf,gBAHe,EAIf,aAJe,EAKf,gBALe,EAMf,cANe,EAOf,WAPe,KAQkD;AACjE,MAAI,KAAK,KAAA;AAAA;AAAT,IAA8C;AAC1C,WAAO,KAAP;AACH;AAED;;;;;;;;;;;;;;;;;;AAkBG;;;AACH,MACK,gBAAgB,GAAG,kBAAnB,IAAyC,cAAc,GAAG,gBAA3D,IACC,gBAAgB,GAAG,kBAAnB,IAAyC,cAAc,GAAG,gBAF/D,EAGE;AACE,WAAO,IAAP;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;;;AACH,MACK,gBAAgB,IAAI,kBAApB,IAA0C,WAAW,IAAI,aAA1D,IACC,cAAc,IAAI,gBAAlB,IAAsC,WAAW,IAAI,aAF1D,EAGE;AACE,WAAA;AAAA;AAAA;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCG;;;AACH,MACK,cAAc,GAAG,gBAAjB,IAAqC,WAAW,GAAG,aAApD,IACC,gBAAgB,GAAG,kBAAnB,IAAyC,WAAW,GAAG,aAF5D,EAGE;AACE,WAAA;AAAA;AAAA;AACH;;AAED,SAAO,IAAP;AACH,CArID;;AAuIA,MAAM,WAAW,GAAI,QAAD,IAAqC;AACrD,SAAO,QAAQ,KAAK,SAAb,IAA0B,QAAQ,KAAK,MAA9C;AACH,CAFD;;AAIA,MAAM,eAAe,GAAI,OAAD,IAAqC;AACzD,MAAI;AACA,WAAO,OAAO,CAAC,aAAR,CAAsB,WAAtB,EAAmC,YAAnC,IAAmD,IAA1D;AACH,GAFD,CAEE,MAAM;AACJ,WAAO,IAAP;AACH;AACJ,CAND;;AAQA,MAAM,YAAY,GAAG,CAAC,OAAD,EAAmB,aAAnB,KAA4E;AAC7F,MAAI,OAAO,CAAC,YAAR,GAAuB,OAAO,CAAC,YAA/B,IAA+C,OAAO,CAAC,WAAR,GAAsB,OAAO,CAAC,WAAjF,EAA8F;AAC1F,WACI,WAAW,CAAC,aAAa,CAAC,SAAf,CAAX,IACA,WAAW,CAAC,aAAa,CAAC,SAAf,CADX,IAEA,OAAO,KAAK,gBAAgB,CAAC,OAAD,CAHhC;AAKH;;AAED,SAAO,KAAP;AACH,CAVD;;AAYA,MAAM,aAAa,GAAI,OAAD,IAAqC;AACvD,QAAM,KAAK,GAAG,OAAO,CAAC,UAAtB;AACA,QAAM,QAAQ,GAAG,OAAO,CAAC,aAAzB;;AAEA,MAAI,QAAQ,KAAK,IAAb,IAAqB,KAAK,KAAK,IAAnC,EAAyC;AACrC,QAAI,KAAK,CAAC,QAAN;AAAmB;AAAmC,MAA1D,EAA8D;AAC1D,aAAQ,KAAoB,CAAC,IAA7B;AACH;;AACD,QAAI,KAAK,CAAC,QAAN;AAAmB;AAA0B,KAAjD,EAAoD;AAChD,aAAO,eAAe,CAAC,OAAD,CAAtB;AACH;AACJ;;AAED,SAAO,QAAP;AACH,CAdD;;AAgBA,MAAM,KAAK,GAAG,CAAC,KAAD,EAAgB,GAAhB,EAA6B,GAA7B,KAAoD;AAC9D,MAAI,KAAK,GAAG,GAAZ,EAAiB;AACb,WAAO,GAAP;AACH;;AAED,MAAI,KAAK,GAAG,GAAZ,EAAiB;AACb,WAAO,GAAP;AACH;;AAED,SAAO,KAAP;AACH,CAVD;;AAYA,MAAM,gCAAgC,GAClC,aADqC,IAEe;AACpD;AACA,SAAQ,CAAC,eAAD,EAAkB,oBAAlB,EAAkD,MAAlD,CACH,QAAD,IAAc,QAAQ,IAAI,aAAa,CAAC,eAAd,CAA8B,KADpD,EAEN,CAFM,CAAR;AAGH,CAPD;;AASA,MAAM,wBAAwB,GAAG,CAC7B,OAD6B,EAE7B,WAF6B,EAG7B,aAH6B,KAI+B;AAC5D,QAAM;AAAE,IAAA,GAAF;AAAO,IAAA,KAAP;AAAc,IAAA,MAAd;AAAsB,IAAA;AAAtB,MAA+B,WAArC;AACA,QAAM,cAAc,GAAG,gCAAgC,CAAC,OAAO,CAAC,aAAT,CAAvD;;AACA,MAAI,CAAC,cAAL,EAAqB;AACjB,WAAO,CAAC,GAAD,EAAM,KAAN,EAAa,MAAb,EAAqB,IAArB,CAAP;AACH;;AAED,QAAM,iBAAiB,GAAI,IAAD,IAAsD;AAC5E,UAAM,KAAK,GAAG,aAAa,CAAC,gBAAd,CAA+B,GAAG,cAAc,IAAI,IAAI,EAAxD,CAAd;AACA,WAAO,QAAQ,CAAC,KAAD,EAAQ,EAAR,CAAR,IAAuB,CAA9B;AACH,GAHD;;AAKA,SAAO,CACH,GAAG,GAAG,iBAAiB,CAAC,KAAD,CADpB,EAEH,KAAK,GAAG,iBAAiB,CAAC,OAAD,CAFtB,EAGH,MAAM,GAAG,iBAAiB,CAAC,QAAD,CAHvB,EAIH,IAAI,GAAG,iBAAiB,CAAC,MAAD,CAJrB,CAAP;AAMH,CAtBD;;AAwBA,MAAM,aAAa,GAAG,CAAC,KAAD,EAAyB,KAAzB,EAAwC,GAAxC,KAA+D;AACjF,UAAQ,KAAR;AACI,SAAA;AAAA;AAAA;AACI,aAAO,CAAC,KAAK,GAAG,GAAT,IAAgB,CAAvB;;AAEJ,SAAA;AAAA;AAAA;AACI,aAAO,GAAP;;AAEJ,SAAA;AAAA;AAAA;AACA,SAAA;AAAA;AAAA;AACI,aAAO,KAAP;AATR;AAWH,CAZD;;AAcA,MAAM,gBAAgB,GAAG,CAAC,KAAD,EAAiB,SAAjB,KAAiD;AACtE,QAAM,cAAc,GAAG,KAAK,CAAC,aAAN,CAAoB,WAApB,EAAiC,cAAxD;AACA,QAAM,CAAC,CAAD,EAAI,CAAJ,EAAO,KAAP,EAAc,MAAd,IACF,KAAK,KAAK,gBAAgB,CAAC,KAAD,CAA1B,GACM,CAAC,CAAD,EAAI,CAAJ,EAAO,cAAc,EAAE,KAAhB,IAAyB,KAAK,CAAC,WAAtC,EAAmD,cAAc,EAAE,MAAhB,IAA0B,KAAK,CAAC,YAAnF,CADN,GAEM,CAAC,SAAS,CAAC,IAAX,EAAiB,SAAS,CAAC,GAA3B,EAAgC,KAAK,CAAC,WAAtC,EAAmD,KAAK,CAAC,YAAzD,CAHV;AAKA,QAAM,IAAI,GAAG,CAAC,GAAG,KAAK,CAAC,UAAvB;AACA,QAAM,GAAG,GAAG,CAAC,GAAG,KAAK,CAAC,SAAtB;AACA,QAAM,KAAK,GAAG,IAAI,GAAG,KAArB;AACA,QAAM,MAAM,GAAG,GAAG,GAAG,MAArB;AAEA,SAAO,CAAC,GAAD,EAAM,KAAN,EAAa,MAAb,EAAqB,IAArB,CAAP;AACH,CAbD;;AAeA,MAAM,qBAAqB,GAAG,CAAC,OAAD,EAAmB,OAAnB,KAAmF;AAC7G;AACA,QAAM,OAAO,GAAiC,EAA9C;AAEA,MAAI,aAAa,GAAG,OAAO,CAAC,aAA5B;AACA,MAAI,WAAW,GAAG,aAAa,CAAC,WAAhC;;AAEA,MAAI,CAAC,WAAL,EAAkB;AACd,WAAO,OAAP;AACH;;AAED,QAAM,aAAa,GAAG,MAAM,CAAC,gBAAP,CAAwB,OAAxB,CAAtB;AACA,QAAM,KAAK,GAAG,aAAa,CAAC,SAAd,KAA4B,KAA1C;AAEA,QAAM,WAAW,GAAG,oBAAoB,CACpC,aAAa,CAAC,WAAd,IACI,aAAa,CAAC,gBAAd,CAA+B,sBAA/B,CADJ,IAEI,aAAa,CAAC,gBAAd,CAA+B,kBAA/B,CAHgC,CAAxC;AAMA,QAAM,CAAC,MAAD,EAAS,MAAT,IAAmB,mBAAmB,CAAC,OAAD,EAAU,WAAV,EAAuB,KAAvB,CAA5C;AAEA,MAAI,CAAC,GAAD,EAAM,KAAN,EAAa,MAAb,EAAqB,IAArB,IAA6B,wBAAwB,CAAC,OAAD,EAAU,OAAO,CAAC,qBAAR,EAAV,EAA2C,aAA3C,CAAzD;;AAEA,OAAK,IAAI,KAAK,GAAG,aAAa,CAAC,OAAD,CAA9B,EAAyC,KAAK,KAAK,IAAnD,EAAyD,KAAK,GAAG,aAAa,CAAC,KAAD,CAA9E,EAAuF;AACnF,QAAI,aAAa,KAAK,KAAK,CAAC,aAA5B,EAA2C;AACvC,MAAA,aAAa,GAAG,KAAK,CAAC,aAAtB;AACA,MAAA,WAAW,GAAG,aAAa,CAAC,WAA5B;;AACA,UAAI,CAAC,WAAL,EAAkB;AACd;AACH;;AAED,YAAM;AAAE,QAAA,IAAI,EAAE,EAAR;AAAY,QAAA,GAAG,EAAE;AAAjB,UAAwB,KAAK,CAAC,qBAAN,EAA9B;AACA,MAAA,GAAG,IAAI,EAAP;AACA,MAAA,KAAK,IAAI,EAAT;AACA,MAAA,MAAM,IAAI,EAAV;AACA,MAAA,IAAI,IAAI,EAAR;AACH;;AAED,UAAM,UAAU,GAAG,WAAW,CAAC,gBAAZ,CAA6B,KAA7B,CAAnB;;AAEA,QAAI,UAAU,CAAC,QAAX,KAAwB,OAA5B,EAAqC;AACjC;AACH;;AAED,QAAI,CAAC,YAAY,CAAC,KAAD,EAAQ,UAAR,CAAjB,EAAsC;AAClC;AACH;;AAED,UAAM,SAAS,GAAG,KAAK,CAAC,qBAAN,EAAlB;AAEA,UAAM,CAAC,QAAD,EAAW,UAAX,EAAuB,WAAvB,EAAoC,SAApC,IAAiD,gBAAgB,CAAC,KAAD,EAAQ,SAAR,CAAvE;AAEA,UAAM,OAAO,GAAG,UAAU,CAAC,MAAD,EAAS,SAAT,EAAoB,UAApB,EAAgC,KAAK,CAAC,WAAtC,EAAmD,IAAnD,EAAyD,KAAzD,EAAgE,KAAK,GAAG,IAAxE,CAA1B;AACA,UAAM,OAAO,GAAG,UAAU,CAAC,MAAD,EAAS,QAAT,EAAmB,WAAnB,EAAgC,KAAK,CAAC,YAAtC,EAAoD,GAApD,EAAyD,MAAzD,EAAiE,MAAM,GAAG,GAA1E,CAA1B;AAEA,UAAM,KAAK,GACP,OAAO,KAAK,IAAZ,GAAmB,CAAnB,GAAuB,aAAa,CAAC,OAAD,EAAU,IAAV,EAAgB,KAAhB,CAAb,GAAsC,aAAa,CAAC,OAAD,EAAU,SAAV,EAAqB,UAArB,CAD9E;AAEA,UAAM,KAAK,GACP,OAAO,KAAK,IAAZ,GAAmB,CAAnB,GAAuB,aAAa,CAAC,OAAD,EAAU,GAAV,EAAe,MAAf,CAAb,GAAsC,aAAa,CAAC,OAAD,EAAU,QAAV,EAAoB,WAApB,CAD9E;AAGA,UAAM,KAAK,GAAG,WAAW,CAAC,UAAD,CAAX,GACR,KAAK,CAAC,KAAD,EAAQ,CAAC,KAAK,CAAC,WAAP,GAAqB,KAAK,CAAC,WAA3B,GAAyC,KAAK,CAAC,UAAvD,EAAmE,CAAC,KAAK,CAAC,UAA1E,CADG,GAER,KAAK,CAAC,KAAD,EAAQ,CAAC,KAAK,CAAC,UAAf,EAA2B,KAAK,CAAC,WAAN,GAAoB,KAAK,CAAC,WAA1B,GAAwC,KAAK,CAAC,UAAzE,CAFX;AAGA,UAAM,KAAK,GAAG,KAAK,CAAC,KAAD,EAAQ,CAAC,KAAK,CAAC,SAAf,EAA0B,KAAK,CAAC,YAAN,GAAqB,KAAK,CAAC,YAA3B,GAA0C,KAAK,CAAC,SAA1E,CAAnB;AAEA,IAAA,OAAO,CAAC,IAAR,CAAa,CACT,KADS,EAET;AAAE,MAAA,IAAI,EAAE,KAAK,CAAC,UAAN,GAAmB,KAA3B;AAAkC,MAAA,GAAG,EAAE,KAAK,CAAC,SAAN,GAAkB,KAAzD;AAAgE,MAAA,QAAQ,EAAE,OAAO,CAAC;AAAlF,KAFS,CAAb;AAKA,IAAA,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,GAAG,KAAf,EAAsB,QAAtB,CAAN;AACA,IAAA,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,KAAjB,EAAwB,UAAxB,CAAR;AACA,IAAA,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,GAAG,KAAlB,EAAyB,WAAzB,CAAT;AACA,IAAA,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,GAAG,KAAhB,EAAuB,SAAvB,CAAP;AACH;;AAED,SAAO,OAAP;AACH,CA9ED;;AAgFA,OAAO,MAAM,cAAc,GAAG,CAC1B,OAD0B,EAE1B,qBAF0B,EAG1B,MAH0B,KAIpB;AACN,QAAM,OAAO,GAAG,qBAAqB,IAAI,EAAzC;;AAEA,MAAI,CAAC,aAAa,CAAC,OAAO,CAAC,QAAT,CAAlB,EAAsC;AAClC,UAAM,IAAI,SAAJ,CAAc,6BAA6B,CAAC,gBAAD,EAAmB,SAAnB,EAA8B,OAAO,CAAC,QAAtC,CAA3C,CAAN;AACH;;AAED,QAAM,OAAO,GAAG,qBAAqB,CAAC,OAAD,EAAU,OAAV,CAArC;AAEA,EAAA,OAAO,CAAC,OAAR,CAAgB,QAA6B;AAAA,QAA5B,CAAC,KAAD,EAAQ,eAAR,CAA4B;AACzC,IAAA,aAAa,CAAC,KAAD,EAAQ,eAAR,EAAyB,MAAzB,CAAb;AACH,GAFD;AAGH,CAhBM;AAkBP,OAAO,MAAM,qBAAqB,GAAG,cAA9B","sourcesContent":["/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step\";\nimport { elementScroll } from \"./scroll.js\";\n\nconst enum ScrollAlignment {\n    ToEdgeIfNeeded,\n    CenterAlways,\n    LeftOrTop,\n    RightOrBottom,\n}\n\nconst enum WritingMode {\n    HorizontalTb,\n    VerticalRl,\n    VerticalLr,\n    SidewaysRl,\n    SidewaysLr,\n}\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode: string): WritingMode => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return WritingMode.HorizontalTb;\n\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return WritingMode.VerticalRl;\n\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return WritingMode.VerticalLr;\n\n        case \"sideways-rl\":\n            return WritingMode.SidewaysRl;\n\n        case \"sideways-lr\":\n            return WritingMode.SidewaysLr;\n    }\n\n    return WritingMode.HorizontalTb;\n};\n\ntype Tuple2<T> = [T, T];\n\nconst calcPhysicalAxis = <T>(writingMode: WritingMode, isLTR: boolean, hPos: T, vPos: T): [number, T, T] => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n\n    const enum OP {\n        ReverseHorizontal = 0b01,\n        ReverseVertical = 0b10,\n    }\n\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= OP.ReverseVertical;\n    }\n\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case WritingMode.HorizontalTb:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case WritingMode.VerticalRl:\n        case WritingMode.SidewaysRl:\n            //  reverse horizontal\n            layout ^= OP.ReverseHorizontal;\n            break;\n\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case WritingMode.SidewaysLr:\n            // reverse vertical\n            layout ^= OP.ReverseVertical;\n            break;\n    }\n\n    return [layout, hPos, vPos];\n};\n\nconst isXReversed = (computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    const layout = calcPhysicalAxis(\n        normalizeWritingMode(computedStyle.writingMode),\n        computedStyle.direction !== \"rtl\",\n        undefined,\n        undefined,\n    )[0];\n    return (layout & 1) === 1;\n};\n\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (\n    options: Readonly<ScrollIntoViewOptions>,\n    writingMode: WritingMode,\n    isLTR: boolean,\n): Tuple2<ScrollAlignment> => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(\n        writingMode,\n        isLTR,\n        options.block || \"start\",\n        options.inline || \"nearest\",\n    );\n\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return ScrollAlignment.CenterAlways;\n            case \"nearest\":\n                return ScrollAlignment.ToEdgeIfNeeded;\n\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? ScrollAlignment.LeftOrTop : ScrollAlignment.RightOrBottom;\n            }\n        }\n    }) as Tuple2<ScrollAlignment>;\n};\n\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (\n    align: ScrollAlignment,\n    scrollingEdgeStart: number,\n    scrollingEdgeEnd: number,\n    scrollingSize: number,\n    elementEdgeStart: number,\n    elementEdgeEnd: number,\n    elementSize: number,\n): Exclude<ScrollAlignment, ScrollAlignment.ToEdgeIfNeeded> | null => {\n    if (align !== ScrollAlignment.ToEdgeIfNeeded) {\n        return align;\n    }\n\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n    ) {\n        return null;\n    }\n\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n    ) {\n        return ScrollAlignment.LeftOrTop;\n    }\n\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if (\n        (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n    ) {\n        return ScrollAlignment.RightOrBottom;\n    }\n\n    return null;\n};\n\nconst canOverflow = (overflow: string | null): boolean => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = (element: Element): Element | null => {\n    try {\n        return element.ownerDocument.defaultView?.frameElement || null;\n    } catch {\n        return null;\n    }\n};\n\nconst isScrollable = (element: Element, computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (\n            canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element)\n        );\n    }\n\n    return false;\n};\n\nconst parentElement = (element: Element): Element | null => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return (pNode as ShadowRoot).host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n\n    return pElement;\n};\n\nconst clamp = (value: number, min: number, max: number): number => {\n    if (value < min) {\n        return min;\n    }\n\n    if (value > max) {\n        return max;\n    }\n\n    return value;\n};\n\nconst getSupportedScrollMarginProperty = (\n    ownerDocument: Document,\n): \"scroll-margin\" | \"scroll-snap-margin\" | undefined => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return ([\"scroll-margin\", \"scroll-snap-margin\"] as const).filter(\n        (property) => property in ownerDocument.documentElement.style,\n    )[0];\n};\n\nconst getElementScrollSnapArea = (\n    element: Element,\n    elementRect: Readonly<DOMRect>,\n    computedStyle: Readonly<CSSStyleDeclaration>,\n): [top: number, right: number, bottom: number, left: number] => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n\n    const scrollMarginValue = (edge: \"top\" | \"right\" | \"bottom\" | \"left\"): number => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\n\nconst calcAlignEdge = (align: ScrollAlignment, start: number, end: number): number => {\n    switch (align) {\n        case ScrollAlignment.CenterAlways:\n            return (start + end) / 2;\n\n        case ScrollAlignment.RightOrBottom:\n            return end;\n\n        case ScrollAlignment.LeftOrTop:\n        case ScrollAlignment.ToEdgeIfNeeded:\n            return start;\n    }\n};\n\nconst getFrameViewport = (frame: Element, frameRect: Readonly<DOMRect>) => {\n    const visualViewport = frame.ownerDocument.defaultView?.visualViewport;\n    const [x, y, width, height] =\n        frame === scrollingElement(frame)\n            ? [0, 0, visualViewport?.width ?? frame.clientWidth, visualViewport?.height ?? frame.clientHeight]\n            : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n\n    return [top, right, bottom, left] as const;\n};\n\nconst computeScrollIntoView = (element: Element, options: ScrollIntoViewOptions): [Element, ScrollToOptions][] => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions: [Element, ScrollToOptions][] = [];\n\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n\n    if (!ownerWindow) {\n        return actions;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n\n    const writingMode = normalizeWritingMode(\n        computedStyle.writingMode ||\n            computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n            computedStyle.getPropertyValue(\"-ms-writing-mode\"),\n    );\n\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n\n        const frameRect = frame.getBoundingClientRect();\n\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n\n        const diffX =\n            eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY =\n            eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n\n    return actions;\n};\n\nexport const scrollIntoView = (\n    element: Element,\n    scrollIntoViewOptions?: ScrollIntoViewOptions,\n    config?: IScrollConfig,\n): void => {\n    const options = scrollIntoViewOptions || {};\n\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n\n    const actions = computeScrollIntoView(element, options);\n\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\n\nexport const elementScrollIntoView = scrollIntoView;\n"]},"metadata":{},"sourceType":"module"}